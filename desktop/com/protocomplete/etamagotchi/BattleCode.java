package com.protocomplete.etamagotchi;

import java.text.ParseException;

/***
Transforms IP addresses into shorter battle code

================================================
STRATEGY
================================================

First char is generated by a bit stream transformed into hex. For example let's
say our battle code is AA1BC1D our first char is 'A' and the rest is the actual packed IP in hex.

This char represents the pattern of the IP. e.g. A1BC1D could be any order combination
of A1.B.C.1D, A.1B.C.1D, A.1.BC.1D etc you get the picture. This char is the bit order of pairs:
e.g. hex code A is 10 is 00001010 in binary and says that '1010' is our pair order.
First set is 2 char, second set is 1 char, third is 2 char, and fourth is 1 char.
Our result is A1.B.C1.D which turns into base16 of a real IP address 161.11.193.13
***/

public class BattleCode {
	public static String pack(String ip) {
    System.out.println("ip: " + ip);

    String[] tokens = ip.split("\\.");

		byte order = 0;

    if(tokens.length != 4) {
      //TODO: throw new ParseException("Not a valid IP address!");
    }

    String result = new String();

    for(int i = 0; i < tokens.length; i++) {
      String hex = Integer.toHexString(Integer.parseInt(tokens[i]));
      System.out.println("hex: " + hex);

      if(hex.length() == 1) {
        order |= 1;
      }

			order = (byte)(order << 1);

			System.out.println("byte order: " + order);

      result += hex;
    }

		result = Integer.toHexString((int)order) + result;

    return result.toUpperCase();
  }

	/*
		Reverse the process above:
		1) Get pair order char
		2) Convert from hex to base 2
		3) Use the 0's in the stream as either single or double char pairs
		4) Read in that many chars
		5) Convert to base 16
		6) Add '.' inbetween pairs
		Return IP string
	*/
  public static String unpack(String code) {
    code = code.toLowerCase();

		char orderCode = code.substring(0, 1).charAt(0);

		int orderBase2 = Integer.parseInt(Character.toString(orderCode), 16);

		byte order = (byte)orderBase2;

		String orderSequence = String.format("%8s", Integer.toBinaryString(order & 0xFF)).replace(' ', '0');

		System.out.println("orderSequence before: " + orderSequence);

		orderSequence = orderSequence.substring(4, 8);

		System.out.println("orderSequence after: " + orderSequence);

    String ip = new String();

    // Lump hex together either single or double chars
		// based on the bits in the orderSequence string
    String pair = new String();
    int pairSize = 0, index = 1, pairIndex = 0;

    while(index < code.length()) {
        pair += code.charAt(index);

				System.out.println("ip: " + ip);

        pairSize++;
        index++;

			int pairSequence = 1 - Integer.parseInt(Character.toString(orderSequence.charAt(pairIndex)));

			System.out.println("pairSequence: " + pairSequence);

      if(pairSize >= pairSequence+1) {
        int base2 = Integer.parseInt(pair, 16);

        pair = "";

        if(ip.length() != 0) {
          ip += ".";
        }

        ip += "" + base2;

				pairIndex++;
        pairSize = 0;
      }
    }

    return ip;
  }
}
